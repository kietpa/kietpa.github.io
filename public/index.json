[{"content":"This article will show how to test a Data Access Object (DAO) in Spring Boot using Testcontainers. Testcontainers is used in tests to create a temporary docker container that contains a real, temporary database instead of mocking it. In this case we will test a DAO that uses JDBCTemplate, a PostgreSQL database, and Flyway for migrations.\nInitial Setup # Create a simple DAO layer with basic CRUD functionalities. In this case we will be using a customer object with id, name, email, age fields.\npackage com.kiet.customer; public class Customer { private Integer id; private String name; private String email; private Integer age; public Customer() {} public Customer(String name, String email, Integer age) { this.name = name; this.email = email; this.age = age; } public Customer(Integer id, String name, String email, Integer age) { this.id = id; this.name = name; this.email = email; this.age = age; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } along with other methods... } public interface CustomerDAO { List\u0026lt;Customer\u0026gt; getAllCustomers(); Optional\u0026lt;Customer\u0026gt; getById(Integer id); void insertCustomer(Customer customer); boolean existsPersonWithEmail(String email); boolean existsPersonWithId(Integer id); void deleteCustomerById(Integer id); void updateCustomer(Customer customer); } package com.kiet.customer; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.stereotype.Repository; import java.util.List; import java.util.Optional; @Repository(\u0026#34;jdbc\u0026#34;) public class CustomerJDBCDataAccessService implements CustomerDAO{ private final JdbcTemplate jdbcTemplate; private final CustomerRowMapper customerRowMapper; public CustomerJDBCDataAccessService(JdbcTemplate jdbcTemplate, CustomerRowMapper customerRowMapper) { this.jdbcTemplate = jdbcTemplate; this.customerRowMapper = customerRowMapper; } @Override public List\u0026lt;Customer\u0026gt; getAllCustomers() { var sql = \u0026#34;\u0026#34;\u0026#34; select id, name, email, age from customer \u0026#34;\u0026#34;\u0026#34;; return jdbcTemplate.query(sql, customerRowMapper); } @Override public Optional\u0026lt;Customer\u0026gt; getById(Integer id) { var sql = \u0026#34;\u0026#34;\u0026#34; select id, name, email, age from customer where id = ? \u0026#34;\u0026#34;\u0026#34;; return jdbcTemplate.query(sql, customerRowMapper, id) .stream() .findFirst(); } @Override public void insertCustomer(Customer customer) { var sql = \u0026#34;\u0026#34;\u0026#34; insert into customer(name, email, age) values(?, ?, ?) \u0026#34;\u0026#34;\u0026#34;; int res = jdbcTemplate.update( sql, customer.getName(), customer.getEmail(), customer.getAge() ); } @Override public boolean existsPersonWithEmail(String email) { var sql = \u0026#34;\u0026#34;\u0026#34; SELECT COUNT(*) from customer where email = ? \u0026#34;\u0026#34;\u0026#34;; Integer count = jdbcTemplate.queryForObject(sql, Integer.class, email); return count \u0026gt; 0 \u0026amp;\u0026amp; count != null; } @Override public boolean existsPersonWithId(Integer id) { var sql = \u0026#34;\u0026#34;\u0026#34; select count(*) from customer where id = ? \u0026#34;\u0026#34;\u0026#34;; Integer count = jdbcTemplate.queryForObject(sql, Integer.class, id); return count \u0026gt; 0 \u0026amp;\u0026amp; count != null; } @Override public void deleteCustomerById(Integer id) { var sql = \u0026#34;\u0026#34;\u0026#34; delete from customer where id = ? \u0026#34;\u0026#34;\u0026#34;; int res = jdbcTemplate.update(sql, id); } @Override public void updateCustomer(Customer update) { if (update.getName() != null) { var sql = \u0026#34;UPDATE customer set name = ? where id = ?\u0026#34;; int res = jdbcTemplate.update(sql, update.getName(), update.getId()); } if (update.getEmail() != null) { var sql = \u0026#34;UPDATE customer set email = ? where id = ?\u0026#34;; int res = jdbcTemplate.update(sql, update.getEmail(), update.getId()); } if (update.getAge() != null) { var sql = \u0026#34;UPDATE customer set age = ? where id = ?\u0026#34;; int res = jdbcTemplate.update(sql, update.getAge(), update.getId()); } } } Create a database schema in src/main/resources/db/migration for Flyway migration. Don\u0026rsquo;t forget to add the Flyway dependency in the pom.xml file.\ncreate table customer( id serial primary key, name text not null, email text not null unique, age int not null ) Create a Testcontainers abstraction class # We create a new Testcontainers abstraction class in the testing folder (eg: com.projectname). Add a field for the Postgres container with the appropriate Postgres docker image.\n@Testcontainers public abstract class AbstractTestcontainers { @Container protected static final PostgreSQLContainer\u0026lt;?\u0026gt; postgreSQLContainer = new PostgreSQLContainer\u0026lt;\u0026gt;(\u0026#34;postgres:latest\u0026#34;) .withDatabaseName(\u0026#34;dao-unit-test\u0026#34;) .withUsername(\u0026#34;john\u0026#34;) .withPassword(\u0026#34;password\u0026#34;); } Add a beforeAll() method that uses Flyway migration to setup the DB schema. We get the datasource credentials from the Postgres field before.\n@Testcontainers public abstract class AbstractTestcontainers { @BeforeAll static void beforeAll() { Flyway flyway = Flyway.configure().dataSource( postgreSQLContainer.getJdbcUrl(), postgreSQLContainer.getUsername(), postgreSQLContainer.getPassword() ).load(); flyway.migrate(); System.out.println(); } @Container protected static final PostgreSQLContainer\u0026lt;?\u0026gt; postgreSQLContainer = new PostgreSQLContainer\u0026lt;\u0026gt;(\u0026#34;postgres:latest\u0026#34;) .withDatabaseName(\u0026#34;dao-unit-test\u0026#34;) .withUsername(\u0026#34;john\u0026#34;) .withPassword(\u0026#34;password\u0026#34;); } Map or register the application\u0026rsquo;s datasource to the Postgres container\u0026rsquo;s credentials using @DynamicPropertySource.\n... @DynamicPropertySource // override datasource w/container private static void registerDataSourceProperties(DynamicPropertyRegistry registry) { registry.add( \u0026#34;spring.datasource.url\u0026#34;, postgreSQLContainer::getJdbcUrl ); registry.add( \u0026#34;spring.datasource.username\u0026#34;, postgreSQLContainer::getUsername ); registry.add( \u0026#34;spring.datasource.password\u0026#34;, postgreSQLContainer::getPassword ); } ... Add a getDataSource() method to get the datasource and inject it to create a JdbcTemplate variable, which will be used in the tests.\nprivate static DataSource getDataSource() { DataSourceBuilder\u0026lt;?\u0026gt; builder = DataSourceBuilder.create() .driverClassName(postgreSQLContainer.getDriverClassName()) .url(postgreSQLContainer.getJdbcUrl()) .username(postgreSQLContainer.getUsername()) .password(postgreSQLContainer.getPassword()); return builder.build(); } protected static JdbcTemplate getJdbcTemplate() { return new JdbcTemplate(getDataSource()); } Create DAO unit tests # Create a CustomerJDBCDataAccessServiceTest class by generating it from the CustomerJDBCDataAccessService class file (right click anywhere in the file \u0026gt; generate \u0026gt; test).\nMake sure the class extends the Testcontainers abstraction class.\npackage com.kiet.customer; import com.kiet.AbstractTestcontainers; class CustomerJDBCDataAccessServiceTest extends AbstractTestcontainers { } Add a CustomerJDBCDataAccessService field that will be tested and inject the JdbcTemplate using getJdbcTemplate(). Using @BeforeEach will make a new instance for each test. A row mapper is also added in this case, but not needed if JPA is used instead of JDBCTemplate.\nclass CustomerJDBCDataAccessServiceTest extends AbstractTestcontainers { private CustomerJDBCDataAccessService underTest; private final CustomerRowMapper customerRowMapper = new CustomerRowMapper(); @BeforeEach void setUp() { underTest = new CustomerJDBCDataAccessService( getJdbcTemplate(), customerRowMapper ); } } Freely add tests using the CustomerJDBCDataAccessService field. This example uses JUnit.\nclass CustomerJDBCDataAccessServiceTest extends AbstractTestcontainers { private CustomerJDBCDataAccessService underTest; private final CustomerRowMapper customerRowMapper = new CustomerRowMapper(); @BeforeEach void setUp() { underTest = new CustomerJDBCDataAccessService( getJdbcTemplate(), customerRowMapper ); } @Test void getAllCustomers() { // GIVEN Customer customer = new Customer( faker.name().fullName(), faker.internet().safeEmailAddress() + \u0026#34;-\u0026#34; + UUID.randomUUID(), 20 ); underTest.insertCustomer(customer); // WHEN List\u0026lt;Customer\u0026gt; actual = underTest.getAllCustomers(); // THEN assertThat(actual).isNotEmpty(); } @Test void getById() { // GIVEN String email = faker.internet().safeEmailAddress() + \u0026#34;-\u0026#34; + UUID.randomUUID(); Customer customer = new Customer( faker.name().fullName(), email, 20 ); underTest.insertCustomer(customer); Integer id = underTest.getAllCustomers() .stream() .filter(c -\u0026gt; c.getEmail().equals(email)) .map(Customer::getId) .findFirst() .orElseThrow(); // WHEN Optional\u0026lt;Customer\u0026gt; actual = underTest.getById(id); System.out.println(actual); // THEN assertThat(actual).isPresent().hasValueSatisfying(c -\u0026gt; { assertThat(c.getId()).isEqualTo(id); assertThat(c.getName()).isEqualTo(customer.getName()); assertThat(c.getAge()).isEqualTo(customer.getAge()); }); } @Test void willReturnEmptyGetById() { // GIVEN int id = -1; // WHEN var actual = underTest.getById(id); // THEN assertThat(actual).isEmpty(); } @Test void insertCustomer() { // GIVEN String email = faker.internet().safeEmailAddress() + \u0026#34;-\u0026#34; + UUID.randomUUID(); Customer customer = new Customer( faker.name().fullName(), email, 20 ); // WHEN underTest.insertCustomer(customer); Optional\u0026lt;Customer\u0026gt; actual = underTest.getAllCustomers() .stream() .filter(c -\u0026gt; c.getEmail().equals(email)) .findFirst(); // THEN assertThat(actual).isPresent().hasValueSatisfying(c -\u0026gt; { assertThat(c.getName()).isEqualTo(customer.getName()); assertThat(c.getName()).isEqualTo(customer.getName()); }); } @Test void existsPersonWithEmail() { // GIVEN String email = faker.internet().safeEmailAddress() + \u0026#34;-\u0026#34; + UUID.randomUUID(); Customer customer = new Customer( faker.name().fullName(), email, 20 ); underTest.insertCustomer(customer); // WHEN boolean actual = underTest.existsPersonWithEmail(email); // THEN assertThat(actual).isTrue(); } @Test void existsPersonWithId() { // GIVEN String email = faker.internet().safeEmailAddress() + \u0026#34;-\u0026#34; + UUID.randomUUID(); Customer customer = new Customer( faker.name().fullName(), email, 20 ); underTest.insertCustomer(customer); Integer id = underTest.getAllCustomers() .stream() .filter(c -\u0026gt; c.getEmail().equals(email)) .map(Customer::getId) .findFirst() .orElseThrow(); // WHEN boolean actual = underTest.existsPersonWithId(id); // THEN assertThat(actual).isTrue(); } @Test void deleteCustomerById() { // GIVEN String email = faker.internet().safeEmailAddress() + \u0026#34;-\u0026#34; + UUID.randomUUID(); Customer customer = new Customer( faker.name().fullName(), email, 20 ); underTest.insertCustomer(customer); Integer id = underTest.getAllCustomers() .stream() .filter(c -\u0026gt; c.getEmail().equals(email)) .map(Customer::getId) .findFirst() .orElseThrow(); // WHEN underTest.deleteCustomerById(id); boolean actual = underTest.existsPersonWithId(id); // THEN assertThat(actual).isFalse(); } @Test void updateCustomer() { // GIVEN String email = faker.internet().safeEmailAddress() + \u0026#34;-\u0026#34; + UUID.randomUUID(); Customer customer = new Customer( faker.name().fullName(), email, 20 ); underTest.insertCustomer(customer); Integer id = underTest.getAllCustomers() .stream() .filter(c -\u0026gt; c.getEmail().equals(email)) .map(Customer::getId) .findFirst() .orElseThrow(); // WHEN Customer customer1 = new Customer( id, faker.name().fullName(), faker.internet().safeEmailAddress() + \u0026#34;-\u0026#34; + UUID.randomUUID(), 22 ); underTest.updateCustomer(customer1); Optional\u0026lt;Customer\u0026gt; actual = underTest.getById(id); // THEN assertThat(actual).isPresent().hasValue(customer1); } } Thanks for reading!\n","date":"11 October 2024","permalink":"/posts/test-jdbctemplate-dao-testcontainers/","section":"Blog","summary":"This article will show how to test a Data Access Object (DAO) in Spring Boot using Testcontainers. Testcontainers is used in tests to create a temporary docker container that contains a real, temporary database instead of mocking it.","title":"How to use Testcontainers for DAO Unit Tests (JdbcTemplate)"},{"content":"Learning Java in Java as a Javanese.\n","date":"11 October 2024","permalink":"/tags/java/","section":"Tags","summary":"Learning Java in Java as a Javanese.","title":"Java"},{"content":"Hi 👋, I\u0026rsquo;m Kiet! This site is meant for me to document the things that I\u0026rsquo;ve learned. Mostly working with Golang and Java.\nProjects ","date":"11 October 2024","permalink":"/","section":"Kiet's blog","summary":"Hi 👋, I\u0026rsquo;m Kiet! This site is meant for me to document the things that I\u0026rsquo;ve learned. Mostly working with Golang and Java.","title":"Kiet's blog"},{"content":"Explore the blog by topic.\n","date":"11 October 2024","permalink":"/tags/","section":"Tags","summary":"Explore the blog by topic.","title":"Tags"},{"content":"We\u0026rsquo;re trying to get them to Pokemon Go to the polls.\n","date":"18 January 2024","permalink":"/tags/golang/","section":"Tags","summary":"We\u0026rsquo;re trying to get them to Pokemon Go to the polls.","title":"Golang"},{"content":"Error handling is one of the things I\u0026rsquo;ve struggled with the most while learning Go. The issue lies in where and how to handle these errors. It\u0026rsquo;s mostly agreed upon that it should be done separately from the main application, but there are many ways to do this and it\u0026rsquo;s hard to decide which one is the \u0026lsquo;best practice\u0026rsquo;. So I thought: why not compile them?\nLet\u0026rsquo;s start with the basics.\nDaisy-chaining # One of the first things I learned in Go, daisy-chaining errors is when errors are wrapped with the method or function that they are in. This is used to make debugging easier as errors show a clear trace when returned. I was really attracted to this idea due to my background of working with PLCs, and the whole concept of a daisy-chain was just neat. Adding context using fmt.Errorf came from Donovan and Kernighan’s book The Go Programming Language.\nfunc thisFunction() error { err := someFunction() return fmt.Errorf(\u0026#34;this function: %w\u0026#34;, err) } func someFunction() error { _, err := stringToInt() return fmt.Errorf(\u0026#34;some function: %w\u0026#34;, err) } func stringToInt() (int, error) { number, err := strconv.Atoi(\u0026#34;five\u0026#34;) if err != nil { return 0, fmt.Errorf(\u0026#34;string to int: %w\u0026#34;, err) } return number, nil } func main() { err := thisFunction() if err != nil { fmt.Println(err) } } In this example the thisFunction calls someFunction, which calls another function stringToInt that returns an error by default. Each of these errors are followed by the name of the function below it.\nthis function: some function: string to int: strconv.Atoi: parsing \u0026#34;five\u0026#34;: invalid syntax This is extremely useful to detect errors that do not return the filename and line of where the error occurred (eg: app/cmd/main.go:23 main.function()) and in applications that have many layers. I found it very useful in my project clothera, a basic CLI app made with native Go.\nDaisy-chaining worked perfectly in that project because a CLI app didn\u0026rsquo;t need to send these errors to higher layer to be handled if it wasn\u0026rsquo;t needed. All you need to do was fmt.Println(err) at the same function and it appears in the terminal.\nThis is why I abandoned this way of error handling once I started building APIs. From seeing other people\u0026rsquo;s code, it was common practice to standardize errors by creating custom ones and handling these errors should ideally be centralized in one layer. In the top layer, asserting the type of error would be difficult. Also, tracing errors could be done through logging package using flags and whatnot.\nSo, daisy-chaining seemed a bit obsolete. Besides using it for basic error logging during development, I don\u0026rsquo;t see it being used anywhere else. Maybe I\u0026rsquo;ll come back to this later in the future.\nCustom Errors # The next error handling method I learned was custom errors. It\u0026rsquo;s not exactly a method, but a standard. A separate file would be created to store these errors, also known as error contracts. These contracts would then be used to replace common, easily handled errors without needing to parse the error any further as there is already a defined global variable.\nimport \u0026#34;errors\u0026#34; var ( ErrBadRequest = errors.New(\u0026#34;bad request\u0026#34;) ErrInternalFailure = errors.New(\u0026#34;internal failure\u0026#34;) ErrNotFound = errors.New(\u0026#34;not found\u0026#34;) ErrFailedBind = errors.New(\u0026#34;failed bind json\u0026#34;) ErrUnauthorized = errors.New(\u0026#34;access unauthorized\u0026#34;) ) ... A basic implementation would include an array of custom errors created by errors.New(), which are then easily identfied using the errors.Is() and errors.As() functions. The errors are passed from the internals to the controllers to be handled in a specific way. For example, ErrFailedBind would indicate that the actual error needed to be parsed to display which of the input fields were invalid, whereas ErrUnauthorized would return the same message to the user everytime. Below is an example of parsing the ErrFailedBind.\nvar Validate *validator.Validate = validator.New() // handle binding errors func ErrorBind(err error) string { var ve validator.ValidationErrors out := \u0026#34;\u0026#34; if errors.As(err, \u0026amp;ve) { for _, fe := range ve { out = fe.Field() + \u0026#34;: \u0026#34; + msgForTag(fe.Tag()) } return out } return out } // error fields func msgForTag(tag string) string { switch tag { case \u0026#34;required\u0026#34;: return \u0026#34;This field is required\u0026#34; case \u0026#34;email\u0026#34;: return \u0026#34;Invalid email\u0026#34; case \u0026#34;alpha\u0026#34;: return \u0026#34;Must be alphabetical\u0026#34; case \u0026#34;gte\u0026#34;: return \u0026#34;Input too short\u0026#34; } return \u0026#34;\u0026#34; } A New Error Type # In my experience, a more convenient way of implementing this in an API is to create a whole new error type APIError that includes the HTTP status code along with the error message.\ntype APIError struct { Code int Message string } var ( ErrInternalServer = APIError{ Code: http.StatusInternalServerError, //500 Message: \u0026#34;Internal Server Error\u0026#34;, } ErrDataNotFound = APIError{ Code: http.StatusOK, //200 Message: \u0026#34;Data Not Found\u0026#34;, } ErrBadRequest = APIError{ Code: http.StatusBadRequest, //400 Message: \u0026#34;Bad request\u0026#34;, } ErrUnauthorized = APIError{ Code: http.StatusUnauthorized, //401 Message: \u0026#34;Request Unauthorized\u0026#34;, } ) These errors are used all over the handlers, where they are entered into a simple ErrorMessage function that logs and returns the error. One of my mentors provided this very simple template in Gin, which he used in his previous job (in a large company).\nimport \u0026#34;github.com/gin-gonic/gin\u0026#34; func ErrorMessage(c *gin.Context, apiError *APIError, err error) *gin.Context { log.Println(err) c.Abort() c.JSON(apiError.Code, gin.H{\u0026#34;error\u0026#34;: APIError{ Code: apiError.Code, Message: apiError.Message, }}) return c } An example handler:\nfunc AddProduct(c *gin.Context) { var product entity.Product err := c.BindJSON(\u0026amp;product) if err != nil { utils.ErrorMessage(c, \u0026amp;utils.ErrBadRequest, err) return } config.DB.Create(\u0026amp;product) c.JSON(200, product) } While this simple approach works well, the way it handles the application error (the actual error) is lacking. There needs to be another function added in some of the handlers which makes it a little messy.\nImplementing the error Interface # A way to expand on the new error type is to implement the error interface by giving the type an Error() method that returns a string of the error. By doing this, it allows you to do some type assertion with errors.As() and handle the app errors semi-gracefully.\ntype error interface { Error() string } In my Hotel 626 project, I used an error type that contains the generic http error and the actual application error, named service error (svcErr) and app error (appErr).\ntype Error struct { svcErr error // generic http error appErr error // actual error } func NewError(svcErr, appErr error) error { return Error{ svcErr: svcErr, appErr: appErr, } } // to be included in the error interface func (e Error) Error() string { return errors.Join(e.svcErr, e.appErr).Error() } In the service layer, the two errors would be wrapped in the Error struct using the NewError function and sent to the handlers above to be parsed. The new error is accepted as a normal error type which makes this convenient.\ntype APIError struct { Status int Message string } func FromError(err error) APIError { var svcError Error var apiError APIError // errors as checks if both are type utils.Error if errors.As(err, \u0026amp;svcError) { // set actual error on message apiError.Message = svcError.AppError().Error() // check error svcErr := svcError.ServiceError() switch svcErr { case ErrFailedBind: apiError.Message = ErrorBind(svcError.AppError()) // check which field fails validation apiError.Status = http.StatusBadRequest case ErrBadRequest: apiError.Status = http.StatusBadRequest case ErrInternalFailure: apiError.Status = http.StatusInternalServerError case ErrNotFound: apiError.Status = http.StatusNotFound case ErrUnauthorized: apiError.Status = http.StatusUnauthorized } } return apiError } In the handlers, the error is parsed by the FromError function which is at the core of this pattern. This function checks whether the received error contains the appErr and SvcErr field using errors.As. If it does, the error wil by casted to the APIError struct that displays the status code and message for the user. This message will be unique for certain errors such as ErrFailedBind which shows which input field is invalid. For other errors, the message will be kept uniform to prevent unwanted information leaks.\nIn cases where the error check fails (usually in a panic), the error is immediately caught by a middleware. In the project I used the one provided by Echo with a basic logger. See the full utils package for more details.\n// located in main e.Use(middleware.RecoverWithConfig(middleware.RecoverConfig{ StackSize: 1 \u0026lt;\u0026lt; 10, // 1 KB LogErrorFunc: utils.LogError, })) // in the utils package func LogError(c echo.Context, err error, stack []byte) error { log.Println(err) return echo.NewHTTPError(http.StatusInternalServerError, err) } This method of error handling is the one that feels the most comfortable to me, because new errors and methods can be easily added to the error contracts and the switch in the FromError function.\nHowever, there is a flaw in the fact that all these errors are located in the utils package/folder and every part of application that uses them are dependant on them, creating tight coupling between packages.\nThe Coupling Problem # In software engineering, coupling or dependency is the degree to which each program module relies on each one of the other modules. This means when a system A is tightly coupled with B, if A changes, B must also change. Tight coupling is usually an unwanted quality to have in an API, as APIs wants its components to be flexible, reusable, and adaptable.\nThe error package I described might not be suited for that since it uses type-assertion where the type of the error is checked. This means that the error types/contracts must be public, which creates a strong coupling with the caller, making for a brittle API. It also violates the Open-closed principle from the SOLID principles. This blog post by Dave Cheney explains these issues much better than I can.\nSo what\u0026rsquo;s the solution? Well, in the same post Cheney said that we should check errors by behaviour instead of type. In this case, the error package only needs to be in the top layer with the handlers. He provides some methods to do this, but I personally have never seen this being done in an actual application. It just seems to hard to implement in some cases.\nThe closest thing I\u0026rsquo;ve seen is not including the full error package in the service. In each service or domain, only the needed error contracts exist. For example, ErrUnauthorized only exists in the user domain.\nSo, should we check by behaviour or type? The answer probably lies in between. Use type when behaviour doesn\u0026rsquo;t work. Though, I\u0026rsquo;ve never really seen this strongly applied anywhere. I might be not advanced enough to see or understand more complex implementations.\nConclusion (I\u0026rsquo;m confused) # In the end, I am still confused on what \u0026lsquo;perfect\u0026rsquo; error handling looks like in Go. Do big companies have a more advanced system? Does it even exist?\nEither way, I think sticking to simple custom errors is enough for now.\nSources # https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully https://blog.dreamfactory.com/the-importance-of-loose-coupling-in-rest-api-design/ https://en.wikipedia.org/wiki/Coupling_(computer_programming) https://www.youtube.com/watch?v=CxcxRgwWtAk ","date":"18 January 2024","permalink":"/posts/custom-error-handling-in-go/","section":"Blog","summary":"Error handling is one of the things I\u0026rsquo;ve struggled with the most while learning Go. The issue lies in where and how to handle these errors.","title":"How do you even handle errors in Go?"},{"content":"Articles that I write in my spare time.\n","date":"13 June 2022","permalink":"/posts/","section":"Blog","summary":"Articles that I write in my spare time.","title":"Blog"},{"content":"Hi, I\u0026rsquo;m Kiet 👋 # I\u0026rsquo;m an aspiring software engineer who works in the back-end. I recently graduated from the Sepuluh Nopember Institute of Technology with a bachelor\u0026rsquo;s degree in Electrical-Engineering (EE). However, I\u0026rsquo;ve decided to pursue a slightly different career path: software engineering.\nPersonally, working in EE; dealing with PLCs, Motors, electrical diagrams, and other technical work wasn\u0026rsquo;t as enjoyable as programming software. The feeling I get seeing my projects come to life (albeit in a screen) is very enjoyable to me.\nMaybe it\u0026rsquo;s the fact that software documentation is more readily available than in EE. I remember spending a whole week reading the manual book of an Omron synchronous motor, and still not understanding a single thing. Whereas with the GCP or Golang docs, it would take much less time to understand since I can look up what other people have said using Google.\nThat\u0026rsquo;s why I want to become a software engineer. Hopefully a good one 😁\n","date":"1 January 0001","permalink":"/about/","section":"Kiet's blog","summary":"Hi, I\u0026rsquo;m Kiet 👋 # I\u0026rsquo;m an aspiring software engineer who works in the back-end. I recently graduated from the Sepuluh Nopember Institute of Technology with a bachelor\u0026rsquo;s degree in Electrical-Engineering (EE).","title":"About Me"},{"content":"","date":"1 January 0001","permalink":"/projects/kiwish/","section":"Projects","summary":"","title":"API Docs"},{"content":"","date":"1 January 0001","permalink":"/projects/letspay/","section":"Projects","summary":"","title":"API Docs"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"This section contains some of my projects and certificates. Other exercises/projects are located in my github.\n🏧 Letspay (WIP) # Letspay is a payment aggregator app that will be integrated with multiple providers such as Xendit \u0026amp; Midtrans. It is made for the purpose of learning technologies such as Grafana logging, Integration with payment providers, microservices, etc. Currently still in progress.\nRepo | API Documentation\n🥝 Kiwish # Kiwish is an e-commerce application with many features, made using microservices and gRPC. Notable features include payment gateway, shipment tracking, and e-mail notifications. The service was deployed on Google Cloud Run, while the databases were deployed on Railway. The project was made together with two of my friends.\nRepo | API Documentation\n🔎 True Sight # Tech Stack:\rGoogle Cloud Flask Kotlin Tensorflow True Sight is a news credibility checker platform that uses Natural Language Processing (NLP) to validate news submitted by users. App was available on Android using an API deployed on Google Cloud Run. I was in charge of designing the Google Cloud infrastructure. Created as the final project of the Bangkit Academy 2022 program with five other teammates.\nRepo | Slideshow\n👔 Clothera # Clothera is a simple CLI app for a Clothing store. Made purely with Golang and MySQL. Created with two of my friends.\nRepo | Slideshow\n🏬 Hotel 626 # A hotel API mini-project made in around 3 days. Created with Golang, PostgreSQL, GORM, and Echo. Includes a Xendit payment gateway and email notifications.\nRepo\n⚙️ DC Motor Speed Control with EKF \u0026amp; PI-PSO # A program to estimate and control the speed of a non-linear DC Motor without using speed sensors, only electrical sensors. The estimation was done using the Extended Kalman Filter (EKF) while the motor was controlled by a PI controller, tuned using the Particle Swarm Optimization (PSO) algorithm. The program was made using MATLAB scripts and Simulink. Created as my final project in university.\nRepo | Slideshow | Article\n📜 Certificates # ☁️ Google Cloud Associate Cloud Engineer # An Associate Cloud Engineer deploys applications, monitors operations, and manages enterprise solutions. This individual is able to use Google Cloud Console and the command-line interface to perform common platform-based tasks to maintain one or more deployed solutions that leverage Google-managed or self-managed services on Google Cloud.\nLink: 5bce81b8cabf428aab3976f6247c4cb7\n📚 TOEFL iBT # The TOEFL iBT® test measures the ability to use and understand academic English. This certification is an asset for international mobility in over 160 countries. This test is a world reference. More than 35 million people worldwide have attested to their English language proficiency by taking the TOEFL iBT test. The test assesses written and oral comprehension and expression skills in an academic context from intermediate to advanced levels.\nFull certificate provided by request.\n","date":"1 January 0001","permalink":"/projects/","section":"Projects","summary":"This section contains some of my projects and certificates. Other exercises/projects are located in my github.\n🏧 Letspay (WIP) # Letspay is a payment aggregator app that will be integrated with multiple providers such as Xendit \u0026amp; Midtrans.","title":"Projects"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"}]